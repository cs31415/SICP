;For debugging
(define (break) 
  (begin 
    (display "break")
    (newline)))
  
(break)
; a.

; Coercion
; Note: Language needs to be Textual(MzScheme, includes R5RS)
; Note: Language needs to be Textual(MzScheme, includes R5RS)
(define h (make-hash-table 'equal))

(define (put op type proc)
  (hash-table-put! h (list op type) proc))

(define (get op type)
  (hash-table-get h (list op type) (lambda () #f)))

; hash table for coercion functions
(define hc (make-hash-table 'equal))
(define (putc op type proc)
  (hash-table-put! h (list op type) proc))

(define (getc op type)
  (hash-table-get h (list op type) (lambda () #f)))

; Raise functions for each type
; integer
(define (integer->rational i)
  (make-rational i 1))

; rational
(define (rational->real r)
  (make-scheme-number (/ (* 1.0 (numer r)) (denom r))))

; real
(define (real->complex r)
  (make-complex-from-real-imag r 0))

;Setup type tower
;integer > rational-number > real > complex
(define (make-typerec typename raisefunc) 
  (cons typename raisefunc))
(define (typename typerec)
  (car typerec))
(define (raiseFunc typerec)
  (cdr typerec))
(define type-tower  (list (make-typerec 'integer integer->rational)
                          (make-typerec 'rational-number rational->real)
                          (make-typerec 'real real->complex)
                          (make-typerec 'complex null)))

; iterate type-tower and setup coercion functions
(define (setup-tower)
  (map (lambda (typerec)
         (if (and (not (null? type-tower)) 
                  (not (null? (car type-tower))))
             (let* ((typerec (car type-tower)))
               (put 'raise (list (car typerec)) (cdr typerec)))
             (error "Bad type definition record")))
       type-tower))
(setup-tower)
  
(define (raise x)
  (begin
    (display "x = ")
    (display x)
    (newline)
    (display "type(x) = ")
    (display (get-type x))
    (newline)
  (apply-generic 'raise x)))

;how do we define this so that the tower is not defined separately
;from the procedure entries?
(define (ishigher? typename1 typename2)
  (define (try remainingtypes)
    (if (and (not (null? remainingtypes))
             (not (null? (car remainingtypes))))
        (let ((nexttypename (typename (car remainingtypes))))
          (if (equal? nexttypename typename1)
            #f
            (if (equal? nexttypename typename2)
                #t
                (try (cdr remainingtypes))))        
        #f)
    ))
  (try type-tower))


"ishigher"
(ishigher? 'complex 'rational-number)

(define (get-type x)
  (let ((type (type-tag x)))
    (if (equal? type 'scheme-number) 
        (if (integer? (contents x)) 'integer 'real)
        type)))

  
; Here we need to check if targettypename is higher than x, only then attempt
; coercion else return the input value
(define (get-coercion x targettypename)
  (if (equal? (get-type x) targettypename)
      x
      (if (ishigher? targettypename (get-type x))
          (let ((rx (raise x)))
            (get-coercion rx targettypename))
          x)))
  
; coerce all to 1st type, then to 2nd, then to 3rd, etc.
(define (apply-generic op . args)
  (define (try op args remainingargs)
    (let ((type-tags (map get-type args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (and (not (null? remainingargs)) 
                     (not (null? (car remainingargs))))
                (let ((cargs 
                       (map 
                        (lambda (x) 
                          (let* ((nextarg (car remainingargs))
                                 (typet (get-type nextarg)))
                            (get-coercion x typet)))
                        args)))
                  (try op cargs (cdr remainingargs)))
                (error "No method for these types"
                           (list op type-tags)))))))
  (try op args args))

(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum -- TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum -- CONTENTS" datum)))
  
(define x (attach-tag 'integer 10))
(get-coercion x 'real)
(raise x)